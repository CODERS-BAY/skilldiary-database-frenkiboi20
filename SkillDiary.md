# SKILL DIARY

## Wednesday, August 26th, 2020

Today it was the turn of the databases. We discussed the DBMS (Database Management System) and the basic structure.
Then we looked at the ERM (Entity Relationship Model) which describes objects and the relationships between them.

-An entity is an object in which information is to be stored.<br>
-Relationship describes the associations between the entities.<br>
-Attributes are the properties of the entities and their relationships.<br>

A frequently used ER model is the Chen notation which graphically shows an overview of all entities and their
relation.

Values ​​are described by primitive data types.<br>
They can be created directly.

### Examples of data types

* int for whole numbers with 32-bit (-2 147 483 648 to 2 147 483 647)
* varchar for strings
* date to store the date
* boolean for true or false values
* float, double for floating point numbers
* char for a single character

Finally, we did a little exercise on the data types.

### Attributes

* A data type is to be assigned to attributes.

### Keys

* The values ​​of the keys clearly identify the entity
* If there are several key candidates, a primary key must be used (e.g .: ID, SVNR, ISBN, etc.)

### Relationships

* Relationships are grouped into relationship types
* Relationships can also contain attributes

### Relationship types

* Unary: A participating entity
* Binary: Two participating entities
* Ternary: Three participating entities

### Cardinalities

* Cardinality describes the relationship more precisely.<br>
  There are four forms: 1:1 1:N N:1 M:N
* They must always be observed.

Finally, we did an exercise on relationship types and cardinalities

* INTEGRATION
* OPERATION
* CATALOG
* USER VIEW
* INTEGRITY ASSURANCE
* ACCESS CONTROL
* TRANSACTIONS
* SYNCHRONIZATION
* DATA BACKUP<br>
were also terms that we took a closer look at.

The parts into which a transaction is divided:
1. Direct debit
2. Credit
3. Confirmation 

Finally, we modeled Coders Bay on a sheet of paper in an ERM. A higher technical school was shown as an exercise in class.


## Thursday, August 27th, 2020

Today it was the turn of software development in Java.

Apart from the recurring problems with my device I managed to close my three-liner after an hour
commiting. Unfortunately, there is still no talk of pushing.

I will try to get further into the program but there is still no chance for me.
At the moment, a proper code creation is not possible at the time, because I only use "try and fail" in the program. 
While I am searching for a menu or a button, after ten minutes I forget what I am doing actually wanted to do.
Unfortunately there was absolutely no familiarization with the IDE.

Since in my opinion the coaches don't have the time to give an introduction in the respective development environment. 
"You err step by step in a direction far from developing".

I feel like I am alone with problems that I cannot solve.

Then Trello stripped down and started IntelliJ. Then we started right away with a few exercises.

After a few lines I tried to execute my code to verify. Unfortunately this failed because I was writing the code in the wrong project. 
How can i know this?? I found out all of this an hour after we got "incorporated" to IntelliJ.

All in all.<br>
In the possible hours available I have brought almost nothing further. I didn't get much of programming,
I was more or less concerned with troubleshooting.<br>
Fact! Another day less!
I was really looking forward to Java because I already had experience with it.

This was one of the worst days on Coders Bay!



## Monday, August 31th, 2020

Jaaaavaaaa :)

Java basics implemented in IntelliJ. The day went well so far. Unfortunately I have to
realize that the basics are not as good as I thought.

I had to ask my trainer a few times because I got stuck.
For example, today we should be programming the game Hangman.
I had my difficulties there.
I am currently still not finished with my work.

It is now 10 o'clock in the evening and my eyes are closing.
I didn't learn very much in class today, but I learned programming
about try and fail. That was funny.



## Wednesday, September 2nd, 2020

And again a new turn of databases :)<br>

To my amazement, this Wednesday went smoothly.<br>
The fear of the ER models was unfounded until now.<br>
Two of my colleagues drew up their versions of the homework/school assignment, which consisted of modeling a library/school system, on the flipchart.

Since our networkers had a final presentation today, which lasted very, very long, the theory input came
a little too short. We wanted to model a hotel together with the trainer. Unfortunately we didn't get around to it.

My main work today was actually only to refine my homework project (library).<br>
The software from "Creatly", with which you can design your models online, helped me a lot.

## Addendum for Thursday, September 3rd, 2020

After a good theoretical input from our trainer, we started to "normalize" our school and library exercise today.

This is done as follows:

### NORMALIZATION

No redundant data (saves storage space, avoids contradicting content)

No more and no less than requested may be changed!
No more and no less than requested may be inserted!
No more and no less than requested may be deleted!

### 1NF -> INDIVISIBILITY (atomization) -> Each field only one value (multiple values ​​are not allowed)

### 2NF -> REDUNDANZ Distribution of primary keys (no key dependencies)
            
### 3NF -> HISTORY -> Split non-key attributes (Transitions)


Based on this information, i tried to implement my concept of the school and the library. So far i've found it extremely difficult
to display entities, relationships and the diagram correctly.

We also tried to resolve N:M relationships into 1:N relationships. 

Aaargh!

P.S: I hope to get more insight into the and structure of DBMS soon.



## Thursday, September 3rd, 2020

Hangman completed!

Motivation: 100%!

Next problem: in sight!

From emotional high into cold water! :)

Today I should develop an algorithm to convert two strings to filter out the common substring.<br>
Turned out to be pretty tricky.
Currently sitting in front of it, I have a solution that calculates the length of the common substring.

Then there is the console roulette etc ..

I'm really looking forward to the next Java day!

## Monday, September 7th, 2020

Today in Java we looked at some popular search algorithms.
We tried to analyze the individual steps of the algorithm on the flipchart.
I had some problems with merge sort and insertion sort that we got as a homework exercise.
Questions that came up at home unfortunately remained unanswered.<br>
Personally, I can't do that much with self-learning, since I've been using self-learning for years anyway to
taught myself some things. To some extent, this methodology is highly recommended, but straight
when building algorithms it would be beneficial to get a little more input.
I am very happy that I like Java, otherwise I would be left behind.

## Wednesday, September 9th, 2020

Unfortunately I wasn't in the class yesterday - family problems!

I couldn't be there when the trainer modeled a cinema. I wasn't present at the following hotel either. At the moment my knowledge of databases is great
limited. It's a shame, because I'm really interested in the subject.
I have to see if I can still follow the lessons.

## Thursday, September 10th, 2020

The last homework in java was three of the well-known search algorithms.<br>
Among other things, the bubble sort, insertion sort and merge sort had to be programmed.<br>
Since I've used Bubblesort several times, this wasn't a big problem. I could still understand the insertion sort, but there is still the merge sort.
Without Google I would not have made any progress. I just think it's a shame that we can't work on such complex things in groups.
If it goes on like this, I'll be drowned in Java.<br>
If I’m honest I would have believed we’re gaining solid knowledge. Whether it is databases, web applications or java.<br>
But I'll fight my way either way.

## Monday, September 14th, 2020

Today it was really bad again.<br>
My knowledge of HTML and CSS is constantly growing, but the complexity is also increasing
too. Right now it would be great to have someone who shows us the tricks to get results quickly.
I'm still miles away from responsiveness, form construction and structuring!<br>
I also lack the talent to incorporate colors, images and other elements.
The Austrian calls it: "Kraut und Ruabm".

## Wednesday, September 16th, 2020

## Hierarchisches Datenbankmodell

### Definition Datenbank:
Datenbanken sind logisch strukturierte Systeme zur elektronischen Datenverwaltung, die mithilfe
eines Datenbank-Management-Systems Zugehörigkeiten und Zugriffsrechte regeln und Informationen
zur enthaltenen Datenbasis speichern. Die meisten Datenbanken lassen sich nur mit speziellen 
Datenbankanwendungen öffnen, bearbeiten und auslesen.


### Grundsätzliches zu Datenbanken:
- Datenbank = Datenbasis = komplette Menge der Daten
- Datenbankmanagementsystem = Verwaltet die Datenbank und bestimmt Struktur, Ordnung, 
  Zugriffsrechte, Abhängigkeiten, etc.
  Mit einer Datenbanksprache und einem geeigneten Datenbankmodell wird die Architektur
  des Datenbanksystems vorgegeben
- sammeln Daten und verknüpfen sie zu einer logischen Einheit
- einzelne Daten werden mit Metainformationen versehen die zur Verarbeitung notwendig sind
- sehr praktisch um große Datenbestände zu verwalten und die Abfrage derer zu erleichtern
- auch die Darstellung sollte erwähnt werden, da die Inhalte bedarfsgerecht und übersichtlich
  angezeigt werden
- Datenbanksysteme unterscheiden sich konzeptionell voneinander und haben individuelle Stärken
  und Schwächen

### Generelles:
- Es gibt hierarchische, netzwerkartige, relationale, objektorientierte und dokumentorientierte
  Datenbanken

### Das hierarchische Datenbankmodell
- ist das älteste DBMS
- bildet die reale Welt durch eine Baumstruktur ab
  d.h.: jeder Datensatz (record) hat genau 1 Vorgänger
        ausser das Wurzelelement (root)

### Das funktioniert folgendermassen:
Man kann ein hierarchisches Datenbankmanagement ansatzweise mit einem Dateisystem vergleichen.
Die Dateien wären die Blätter,
Verzeichnisse entsprechen den Knoten mit Kindern.

Die Daten werden in Datensätzen gespeichert die mit Feldern verknüpft sind.
Die Instanzen eines Datensatzes werden als Datensatzabbild zusammengefasst.
Diese Abbilder haben Ähnlichkeit mit den Tabellen aus einer relationalen
Datenbank.

Abhängigkeiten zwischen den Datensätzen werden in sogenannten Eltern-Kind-Beziehungen (PCR)
realisiert. Man beginnt oben mit dem root-element und erweitert so nach und nach
seine Verknüpfungen. Durch diese Vorgehensweise entsteht ein Gebilde das einem
Baum ähnlich sieht

### Nachteil:
- Hierarchische Datenbanken können nur mit einem solchen Baum umgehen. 
- Verknüpfungen bzw. Beziehungen zwischen verschiedenen Bäumen oder über mehrere
  Ebenen sind nicht möglich.
- Es lassen sich keine N:M Beziehungen darstellen (können entweder nur über Redundanzen
  erreicht werden, oder über virtuelle Parent-Child-Relationships (VPCR)
- unflexibel, weil man immer über Hierarchie auf den gewünschten Datensatz kommt
- man muss die Zugriffspfade kennen

### Vorteil:
- Einfach zu verstehen
- Einfacher Zugriff auf zusammengehörige Daten
- Kurze Zugriffszeit für festgelegte Suchpfade
- Verarbeitung von Stücklisten möglich
- eignet sich für XML-Daten

### Minimalbedingungen:
- 1 Datensatz (record) muss das Wurzelelement (root) darstellen. Deswegen kann dieses
  Element kein Child (Kindelement) besitzen
- Jeder andere Datensatz ist auch ein Child
- Jeder Datensatz der nicht als Parent (Elternelement) auftritt, wird Blatt
  genannt

### Fazit:
Heutzutage ist das hierarchische Modell weitgehend von anderen Modellen abgelöst worden. Eine
Renaissance erlebt die hierarchische Datenspeicherung mit XML
XML = eine Metasprache auf deren Basis durch strukturelle und inhaltliche Einschränkungen
      anwendungsspezifische Sprachen definiert werden

<hr>

## Hierarchical database model

### Definition of database:
Databases are logically structured systems for electronic data management that use
a database management system to regulate affiliations and access rights and information
save to the contained database. Most databases can only be opened with special
Opening-, editing and reading- database applications.

### Basics about databases:
- Database = database = complete amount of data
- Database management system = Manages the database and determines structure, order,
  Access rights, dependencies, etc.<br>
  With a database language and a suitable database model, the architecture
  of the database system
- Collect data and combine them into a logical unit
- Individual data are provided with meta information that is necessary for processing
- Very practical to manage large amounts of data and to make it easier to query them
- The presentation should also be mentioned, as the content is clear and needs-based
  are displayed
- Database systems differ conceptually from one another and have individual strengths
  and weaknesses

### General:
- There are hierarchical, network-like, relational, object-oriented and document-oriented
  Databases

### The hierarchical database model
- is the oldest DBMS
- depicts the real world through a tree structure
  i.e .: every data record (record) has exactly 1 predecessor
        except for the root element

### It works as follows:
You can roughly compare hierarchical database management with a file system.
The files would be the sheets
Directories correspond to nodes with children.

The data is stored in data sets that are linked to fields.
The instances of a data record are summarized as a data record image.
These images are similar to the tables from a relational
Database.

Dependencies between the data sets are identified in so-called parent-child relationships (PCR)
realized. You start at the top with the root element and gradually expand
its shortcuts. This approach creates a structure that becomes one
Tree looks similar

### Disadvantage:
Hierarchical databases can only deal with such a tree.
- Links or relationships between different trees or across several trees
  Levels are not possible.
- No N: M relationships can be represented (either only via redundancies
  can be reached, or via virtual parent-child relationships (VPCR)
- Inflexible, because you always get to the desired data record via hierarchy
- you have to know the access paths

### Advantage:
- Easy to understand
- Easy access to related data
- Short access time for defined search paths
- Processing of parts lists possible
- is suitable for XML data

### Minimum conditions:
- 1 data record (record) must represent the root element (root). Therefore this can
  Element do not have a child
- Every other data set is also a child
- Every data record that does not appear as a parent (parent element) becomes a leaf
  called

### Conclusion:
Nowadays the hierarchical model has largely been replaced by other models. A
The hierarchical data storage with XML is experiencing a renaissance
XML = a metalanguage based on it through structural and content restrictions
      application-specific languages ​​can be defined

## 17th September, 2020

Yeah Today I revised a very dirty code (bingo exercise).
My trainer found it extremely entertaining to show my mega-redundant code publicly.
I took it with humor.

Also, I finally finished the Divide and Conquer example.
After 2 endless hours of debugging, I found the bug. I iterated over the whole array instead of over the sub-arrays.

All in all it was a successful Java day!

